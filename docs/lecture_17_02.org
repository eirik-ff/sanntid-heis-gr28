* Patterns
  Patterns that improve code quality etc.
** Kinds of software
*** persistent
- runs in the loop for a long time
*** Robust
- high cost of fixing
- the system as a whole must function in extraordinary conditions
* Pattern 1: State machines
*** Requirements:
- Software runs in a loop
- the outputs depends on the order/history of inputs
- Some combinations of outputs are invalid
- Some combinations of inputs are invalid
*** Goals:
- Make a framework/ patterns that
  - loops
  - reacts conditionally based on previous inputs/outputs
  - makes invalid combinations inexpressible
- Understand this pattern in terms of analytical and intuitive approaches to applying it.
  - Why this pattern is better than the alternatives
** Step 1: Connect
- Find the inputs and outputs the system has
- These should be formulated as discrete-time
  - Think events/change, as opposed to current value/state
*** For elevator:
Inputs:
- Button press (and release)
- Floor sensor
- Stop button
- Timers
Outputs:
- Motor direction
- Door
- Floor indicator
- button lights
- stop button light
** Step 2: Persist
Some received inputs or set outputs must be stored for later
Goal: 
- stored data should be minimal
- No duplicates or invalid combinations
Methods:
- Analytical
- intuitive
- Smart: a bit of both

*** Stored inputs:
- What button pressed
- what floor last on
- if between floors
- if stop button
*** Stored outputs:
- If we are moving
- what direction
- if a door is open
- what buttons are on

** Step 3: Minimize
Tries to use intuition to find out what we need and don't need.
Don't need:
  - Call button lights (have simple 1-to-1 mapping from inputs)
Can be factored out:
  - Floor number
  - direction
Things that are too big:
  - What buttons have been pressed?
  - Instead use queries, like any?, above? below? any at floor x?
Things that have one-shot:
  - Door close timer

Left with fewer events than at step 2.
Create table with states that are invalid/undesired.
Create table with states that are left after removing invalid/undesired states.
** Step 4: React
We have the components for out state-machine, events, unique states.
Function (inputs, state, data)(t) -> (outputs, state, data)(t+1)

Should we look at the inputs first or the state..?
- The option that creates the least amount of code duplication.
Input-first.
- Some inputs have the same action no matter the current state..
- Some inputs are only accepted in particular states.

* Pattern 2: Code quality
** Goals
- Testable code is good
- (Proposal, claim) If the code is testable -> code does not actually need the tests
** What makes the code testable?
- Easy - repeatable input- output relations
- Hard - dependencies on things outside out control
  - External inputs
  - Out of scope inputs
- Also hard - unknown dependencies
  - Things that could be accesses, but aren't
** Generalization of that to test things
- Interactions
- Shared ownership
- The outside world
- *Modification* is hard to test.

* Pattern 2a: Core and Shell
Code can be separated into:
- Finding out what action to be performed
- Performing the action

Doing this separates out the hard-to test parts.

** Core
Code with explicit inputs and outputs
- Only parameters and return values
- *Pure functions*
Contains the *logic*
Easy to test
** Shell
Receive the input, modifies the state and outputs
- variables
- Comm
- no loops, no conditionals (at least very few
Hard to write tests for
No branches, just executes.
** What this pattern achieves
- Separates decision and action
  - Allows testing
  - Makes modifying actions into trivial straight line code that needs little testing.
* Pattern 2b: Separation by Modification
Would be hard to have everything in one huge FSM
Goals:
- Smaller parts
- Split into smaller state machines
- (Must communicate in some way)
- Avoid shared modification
- Unique ownership for data and outputs

** Outputs
Shared modification is only necessary when data is spread out
** Inputs
Data duplication is only a problem if there is a synchronization requirement
Lack of sync. is only observable from the output
Sync. of outputs is handled by grouping

** conclusion
split data based on if it need to be modified together
Get copies of other data if necessary
Put each group of data in their own state-machines


** Ex. 1: Elevator project
Can be divided into three parts:
1. Distribution
2. Assignment
3. Execution

Distribution and assignment take some effort to untangle, but is possible with some thought.
** Ex. 2: Obstructed door
   Can write the obstructed door as a 5 state state-machine (open, closed, openOvertime, Obstructed, Stuck)
Two timers: normal timeout, overtime timeout
** Parallel state-machine
Fewer total enumerated states.
Might be more total states.
- If interactions between state-machine are under control (clearly defined), will not be a problem.
* Pattern 2c: Interacting state-machines
Goals:
As few interactions as possible (simple)
- No shared data/references
- No synchronizations (preferably)
** Processes and Objects
- The object - input event is passed as parameter to a function
- The process- input event is sent as a message in a channel/queue

** Problems with objects
Objects don't do anything, someone has to call it.
Someone need to invoke behavior in it through direct manipulation
Can't run in parallel (can't run)
If they need to interact with each other, they need circular references
  - Who is responsible
If you get access to one public method, you get access to all methods.
Testing requires connecting objects.
  - either a real one, or fake doubles/mocks.

** Processes
Kind of thread, run independently
Connected with queues/channels
  - Modification is a request, not performed directly.
Expose channel, not complete interface
Testing single process requires just the channels (interface) for that process

*** What it achieves
Allows testing of single processes without setting up other processes, or create mocks of other processes/objects
Eliminates potential interactions to consider by exposing a partitionable interface.
No need for synchronization
Makes within program communication follow the same pattern as between program communication.
